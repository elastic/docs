<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title xmlns="">Highlighting
        | Elasticsearch Reference [5.1]
      | Elastic
    </title><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Elasticsearch Reference [5.1]" /><link rel="up" href="search-request-body.html" title="Request Body Search" /><link rel="prev" href="search-request-post-filter.html" title="Post filter" /><link rel="next" href="search-request-rescore.html" title="Rescoring" /><meta xmlns="" name="description" content="Get started with the documentation for Elasticsearch, Kibana, Logstash, Beats, X-Pack, Elastic Cloud, Elasticsearch for Apache Hadoop, and our language clients." /><meta xmlns="" name="DC.type" content="Docs/Elasticsearch/Reference/5.1" /></head><body><div xmlns="" class="page_header">You are looking at documentation for an older release.
Not what you want? See the
<a href="../current/index.html">current release documentation</a>.
</div><div xmlns="" class="breadcrumbs"><span class="breadcrumb-link"><a href="index.html">Elasticsearch Reference
      [5.1]
    </a></span> » <span class="breadcrumb-link"><a href="search.html">Search APIs</a></span> » <span class="breadcrumb-link"><a href="search-request-body.html">Request Body Search</a></span> » <span class="breadcrumb-node">Highlighting</span></div><div xmlns="" class="navheader"><span class="prev"><a href="search-request-post-filter.html">
              « 
              Post filter</a>
           
        </span><span class="next">
           
          <a href="search-request-rescore.html">Rescoring
               »
            </a></span></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="search-request-highlighting"></a>Highlighting<a xmlns="" href="https://github.com/elastic/elasticsearch/edit/5.1/docs/reference/search/request/highlighting.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h2></div></div></div><p>Allows to highlight search results on one or more fields. The
implementation uses either the lucene <code class="literal">plain</code> highlighter, the
fast vector highlighter (<code class="literal">fvh</code>) or <code class="literal">postings</code> highlighter.
The following is an example of the search request body:</p><div xmlns="" class="pre_wrapper"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">GET /_search
{
    "query" : {
        "match": { "content": "kimchy" }
    },
    "highlight" : {
        "fields" : {
            "content" : {}
        }
    }
}</pre></div><div xmlns="" class="console_widget" data-snippet=":CONSOLE:"></div><p>In the above case, the <code class="literal">content</code> field will be highlighted for each
search hit (there will be another element in each search hit, called
<code class="literal">highlight</code>, which includes the highlighted fields and the highlighted
fragments).</p><div xmlns="" class="note admon"><div class="icon"><img alt="Note" src="images/icons/note.png" /></div><div class="admon_content"><p xmlns="http://www.w3.org/1999/xhtml">In order to perform highlighting, the actual content of the field is
required. If the field in question is stored (has <code class="literal">store</code> set to <code class="literal">true</code>
in the mapping) it will be used, otherwise, the actual <code class="literal">_source</code> will
be loaded and the relevant field will be extracted from it.</p><p xmlns="http://www.w3.org/1999/xhtml">The <code class="literal">_all</code> field cannot be extracted from <code class="literal">_source</code>, so it can only
be used for highlighting if it mapped to have <code class="literal">store</code> set to <code class="literal">true</code>.</p></div></div><p>The field name supports wildcard notation. For example, using <code class="literal">comment_*</code>
will cause all <a class="link" href="text.html" title="Text datatype">text</a> and <a class="link" href="keyword.html" title="Keyword datatype">keyword</a> fields (and <a class="link" href="string.html" title="String datatype">string</a>
from versions before 5.0) that match the expression to be highlighted.
Note that all other fields will not be highlighted. If you use a custom mapper and want to
highlight on a field anyway, you have to provide the field name explicitly.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="plain-highlighter"></a>Plain highlighter<a xmlns="" href="https://github.com/elastic/elasticsearch/edit/5.1/docs/reference/search/request/highlighting.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h3></div></div></div><p>The default choice of highlighter is of type <code class="literal">plain</code> and uses the Lucene highlighter.
It tries hard to reflect the query matching logic in terms of understanding word importance and any word positioning criteria in phrase queries.</p><div xmlns="" class="warning admon"><div class="icon"><img alt="Warning" src="images/icons/warning.png" /></div><div class="admon_content"><p xmlns="http://www.w3.org/1999/xhtml">If you want to highlight a lot of fields in a lot of documents with complex queries this highlighter will not be fast.
In its efforts to accurately reflect query logic it creates a tiny in-memory index and re-runs the original query criteria through
Lucene’s query execution planner to get access to low-level match information on the current document.
This is repeated for every field and every document that needs highlighting. If this presents a performance issue in your system consider using an alternative highlighter.</p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="postings-highlighter"></a>Postings highlighter<a xmlns="" href="https://github.com/elastic/elasticsearch/edit/5.1/docs/reference/search/request/highlighting.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h3></div></div></div><p>If <code class="literal">index_options</code> is set to <code class="literal">offsets</code> in the mapping the postings highlighter
will be used instead of the plain highlighter. The postings highlighter:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
Is faster since it doesn’t require to reanalyze the text to be highlighted:
the larger the documents the better the performance gain should be
</li><li class="listitem">
Requires less disk space than term_vectors, needed for the fast vector
highlighter
</li><li class="listitem">
Breaks the text into sentences and highlights them. Plays really well with
natural languages, not as well with fields containing for instance html markup
</li><li class="listitem">
Treats the document as the whole corpus, and scores individual sentences as
if they were documents in this corpus, using the  BM25 algorithm
</li></ul></div><p>Here is an example of setting the <code class="literal">content</code> field in the index mapping to allow for
highlighting using the postings highlighter on it:</p><div xmlns="" class="pre_wrapper"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">{
    "type_name" : {
        "content" : {"index_options" : "offsets"}
    }
}</pre></div><div xmlns="" class="note admon"><div class="icon"><img alt="Note" src="images/icons/note.png" /></div><div class="admon_content"><p xmlns="http://www.w3.org/1999/xhtml">Note that the postings highlighter is meant to perform simple query terms
highlighting, regardless of their positions. That means that when used for
instance in combination with a phrase query, it will highlight all the terms
that the query is composed of, regardless of whether they are actually part of
a query match, effectively ignoring their positions.</p></div></div><div xmlns="" class="warning admon"><div class="icon"><img alt="Warning" src="images/icons/warning.png" /></div><div class="admon_content"><p xmlns="http://www.w3.org/1999/xhtml">The postings highlighter doesn’t support highlighting some complex queries,
like a <code class="literal">match</code> query with <code class="literal">type</code> set to <code class="literal">match_phrase_prefix</code>. No highlighted
snippets will be returned in that case.</p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="fast-vector-highlighter"></a>Fast vector highlighter<a xmlns="" href="https://github.com/elastic/elasticsearch/edit/5.1/docs/reference/search/request/highlighting.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h3></div></div></div><p>If <code class="literal">term_vector</code> information is provided by setting <code class="literal">term_vector</code> to
<code class="literal">with_positions_offsets</code> in the mapping then the fast vector highlighter
will be used instead of the plain highlighter.  The fast vector highlighter:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
Is faster especially for large fields (&gt; <code class="literal">1MB</code>)
</li><li class="listitem">
Can be customized with <code class="literal">boundary_chars</code>, <code class="literal">boundary_max_scan</code>, and
 <code class="literal">fragment_offset</code> (see <a class="link" href="search-request-highlighting.html#boundary-characters" title="Boundary Characters">below</a>)
</li><li class="listitem">
Requires setting <code class="literal">term_vector</code> to <code class="literal">with_positions_offsets</code> which
  increases the size of the index
</li><li class="listitem">
Can combine matches from multiple fields into one result.  See
  <code class="literal">matched_fields</code>
</li><li class="listitem">
Can assign different weights to matches at different positions allowing
  for things like phrase matches being sorted above term matches when
  highlighting a Boosting Query that boosts phrase matches over term matches
</li></ul></div><p>Here is an example of setting the <code class="literal">content</code> field to allow for
highlighting using the fast vector highlighter on it (this will cause
the index to be bigger):</p><div xmlns="" class="pre_wrapper"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">{
    "type_name" : {
        "content" : {"term_vector" : "with_positions_offsets"}
    }
}</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_force_highlighter_type"></a>Force highlighter type<a xmlns="" href="https://github.com/elastic/elasticsearch/edit/5.1/docs/reference/search/request/highlighting.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h3></div></div></div><p>The <code class="literal">type</code> field allows to force a specific highlighter type. This is useful
for instance when needing to use the plain highlighter on a field that has
<code class="literal">term_vectors</code> enabled. The allowed values are: <code class="literal">plain</code>, <code class="literal">postings</code> and <code class="literal">fvh</code>.
The following is an example that forces the use of the plain highlighter:</p><div xmlns="" class="pre_wrapper"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">GET /_search
{
    "query" : {
        "match": { "user": "kimchy" }
    },
    "highlight" : {
        "fields" : {
            "content" : {"type" : "plain"}
        }
    }
}</pre></div><div xmlns="" class="console_widget" data-snippet=":CONSOLE:"></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_force_highlighting_on_source"></a>Force highlighting on source<a xmlns="" href="https://github.com/elastic/elasticsearch/edit/5.1/docs/reference/search/request/highlighting.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h3></div></div></div><p>Forces the highlighting to highlight fields based on the source even if fields are
stored separately. Defaults to <code class="literal">false</code>.</p><div xmlns="" class="pre_wrapper"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">GET /_search
{
    "query" : {
        "match": { "user": "kimchy" }
    },
    "highlight" : {
        "fields" : {
            "content" : {"force_source" : true}
        }
    }
}</pre></div><div xmlns="" class="console_widget" data-snippet=":CONSOLE:"></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="tags"></a>Highlighting Tags<a xmlns="" href="https://github.com/elastic/elasticsearch/edit/5.1/docs/reference/search/request/highlighting.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h3></div></div></div><p>By default, the highlighting will wrap highlighted text in <code class="literal">&lt;em&gt;</code> and
<code class="literal">&lt;/em&gt;</code>. This can be controlled by setting <code class="literal">pre_tags</code> and <code class="literal">post_tags</code>,
for example:</p><div xmlns="" class="pre_wrapper"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">GET /_search
{
    "query" : {
        "match": { "user": "kimchy" }
    },
    "highlight" : {
        "pre_tags" : ["&lt;tag1&gt;"],
        "post_tags" : ["&lt;/tag1&gt;"],
        "fields" : {
            "_all" : {}
        }
    }
}</pre></div><div xmlns="" class="console_widget" data-snippet=":CONSOLE:"></div><p>Using the fast vector highlighter there can be more tags, and the "importance"
is ordered.</p><div xmlns="" class="pre_wrapper"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">GET /_search
{
    "query" : {
        "match": { "user": "kimchy" }
    },
    "highlight" : {
        "pre_tags" : ["&lt;tag1&gt;", "&lt;tag2&gt;"],
        "post_tags" : ["&lt;/tag1&gt;", "&lt;/tag2&gt;"],
        "fields" : {
            "_all" : {}
        }
    }
}</pre></div><div xmlns="" class="console_widget" data-snippet=":CONSOLE:"></div><p>There are also built in "tag" schemas, with currently a single schema
called <code class="literal">styled</code> with the following <code class="literal">pre_tags</code>:</p><div xmlns="" class="pre_wrapper"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">&lt;em class="hlt1"&gt;, &lt;em class="hlt2"&gt;, &lt;em class="hlt3"&gt;,
&lt;em class="hlt4"&gt;, &lt;em class="hlt5"&gt;, &lt;em class="hlt6"&gt;,
&lt;em class="hlt7"&gt;, &lt;em class="hlt8"&gt;, &lt;em class="hlt9"&gt;,
&lt;em class="hlt10"&gt;</pre></div><p>and <code class="literal">&lt;/em&gt;</code> as <code class="literal">post_tags</code>. If you think of more nice to have built in tag
schemas, just send an email to the mailing list or open an issue. Here
is an example of switching tag schemas:</p><div xmlns="" class="pre_wrapper"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">GET /_search
{
    "query" : {
        "match": { "user": "kimchy" }
    },
    "highlight" : {
        "tags_schema" : "styled",
        "fields" : {
            "content" : {}
        }
    }
}</pre></div><div xmlns="" class="console_widget" data-snippet=":CONSOLE:"></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_encoder"></a>Encoder<a xmlns="" href="https://github.com/elastic/elasticsearch/edit/5.1/docs/reference/search/request/highlighting.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h3></div></div></div><p>An <code class="literal">encoder</code> parameter can be used to define how highlighted text will
be encoded. It can be either <code class="literal">default</code> (no encoding) or <code class="literal">html</code> (will
escape html, if you use html highlighting tags).</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_highlighted_fragments"></a>Highlighted Fragments<a xmlns="" href="https://github.com/elastic/elasticsearch/edit/5.1/docs/reference/search/request/highlighting.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h3></div></div></div><p>Each field highlighted can control the size of the highlighted fragment
in characters (defaults to <code class="literal">100</code>), and the maximum number of fragments
to return (defaults to <code class="literal">5</code>).
For example:</p><div xmlns="" class="pre_wrapper"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">GET /_search
{
    "query" : {
        "match": { "user": "kimchy" }
    },
    "highlight" : {
        "fields" : {
            "content" : {"fragment_size" : 150, "number_of_fragments" : 3}
        }
    }
}</pre></div><div xmlns="" class="console_widget" data-snippet=":CONSOLE:"></div><p>The <code class="literal">fragment_size</code> is ignored when using the postings highlighter, as it
outputs sentences regardless of their length.</p><p>On top of this it is possible to specify that highlighted fragments need
to be sorted by score:</p><div xmlns="" class="pre_wrapper"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">GET /_search
{
    "query" : {
        "match": { "user": "kimchy" }
    },
    "highlight" : {
        "order" : "score",
        "fields" : {
            "content" : {"fragment_size" : 150, "number_of_fragments" : 3}
        }
    }
}</pre></div><div xmlns="" class="console_widget" data-snippet=":CONSOLE:"></div><p>If the <code class="literal">number_of_fragments</code> value is set to <code class="literal">0</code> then no fragments are
produced, instead the whole content of the field is returned, and of
course it is highlighted. This can be very handy if short texts (like
document title or address) need to be highlighted but no fragmentation
is required. Note that <code class="literal">fragment_size</code> is ignored in this case.</p><div xmlns="" class="pre_wrapper"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">GET /_search
{
    "query" : {
        "match": { "user": "kimchy" }
    },
    "highlight" : {
        "fields" : {
            "_all" : {},
            "bio.title" : {"number_of_fragments" : 0}
        }
    }
}</pre></div><div xmlns="" class="console_widget" data-snippet=":CONSOLE:"></div><p>When using <code class="literal">fvh</code> one can use <code class="literal">fragment_offset</code>
parameter to control the margin to start highlighting from.</p><p>In the case where there is no matching fragment to highlight, the default is
to not return anything. Instead, we can return a snippet of text from the
beginning of the field by setting <code class="literal">no_match_size</code> (default <code class="literal">0</code>) to the length
of the text that you want returned. The actual length may be shorter than
specified as it tries to break on a word boundary. When using the postings
highlighter it is not possible to control the actual size of the snippet,
therefore the first sentence gets returned whenever <code class="literal">no_match_size</code> is
greater than <code class="literal">0</code>.</p><div xmlns="" class="pre_wrapper"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">GET /_search
{
    "query" : {
        "match": { "user": "kimchy" }
    },
    "highlight" : {
        "fields" : {
            "content" : {
                "fragment_size" : 150,
                "number_of_fragments" : 3,
                "no_match_size": 150
            }
        }
    }
}</pre></div><div xmlns="" class="console_widget" data-snippet=":CONSOLE:"></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_highlight_query"></a>Highlight query<a xmlns="" href="https://github.com/elastic/elasticsearch/edit/5.1/docs/reference/search/request/highlighting.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h3></div></div></div><p>It is also possible to highlight against a query other than the search
query by setting <code class="literal">highlight_query</code>.  This is especially useful if you
use a rescore query because those are not taken into account by
highlighting by default.  Elasticsearch does not validate that
<code class="literal">highlight_query</code> contains the search query in any way so it is possible
to define it so legitimate query results aren’t highlighted at all.
Generally it is better to include the search query in the
<code class="literal">highlight_query</code>.  Here is an example of including both the search
query and the rescore query in <code class="literal">highlight_query</code>.</p><div xmlns="" class="pre_wrapper"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">GET /_search
{
    "stored_fields": [ "_id" ],
    "query" : {
        "match": {
            "content": {
                "query": "foo bar"
            }
        }
    },
    "rescore": {
        "window_size": 50,
        "query": {
            "rescore_query" : {
                "match_phrase": {
                    "content": {
                        "query": "foo bar",
                        "slop": 1
                    }
                }
            },
            "rescore_query_weight" : 10
        }
    },
    "highlight" : {
        "order" : "score",
        "fields" : {
            "content" : {
                "fragment_size" : 150,
                "number_of_fragments" : 3,
                "highlight_query": {
                    "bool": {
                        "must": {
                            "match": {
                                "content": {
                                    "query": "foo bar"
                                }
                            }
                        },
                        "should": {
                            "match_phrase": {
                                "content": {
                                    "query": "foo bar",
                                    "slop": 1,
                                    "boost": 10.0
                                }
                            }
                        },
                        "minimum_should_match": 0
                    }
                }
            }
        }
    }
}</pre></div><div xmlns="" class="console_widget" data-snippet=":CONSOLE:"></div><p>Note that the score of text fragment in this case is calculated by the Lucene
highlighting framework. For implementation details you can check the
<code class="literal">ScoreOrderFragmentsBuilder.java</code> class. On the other hand when using the
postings highlighter the fragments are scored using, as mentioned above,
the BM25 algorithm.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="highlighting-settings"></a>Global Settings<a xmlns="" href="https://github.com/elastic/elasticsearch/edit/5.1/docs/reference/search/request/highlighting.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h3></div></div></div><p>Highlighting settings can be set on a global level and then overridden
at the field level.</p><div xmlns="" class="pre_wrapper"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">GET /_search
{
    "query" : {
        "match": { "user": "kimchy" }
    },
    "highlight" : {
        "number_of_fragments" : 3,
        "fragment_size" : 150,
        "fields" : {
            "_all" : { "pre_tags" : ["&lt;em&gt;"], "post_tags" : ["&lt;/em&gt;"] },
            "bio.title" : { "number_of_fragments" : 0 },
            "bio.author" : { "number_of_fragments" : 0 },
            "bio.content" : { "number_of_fragments" : 5, "order" : "score" }
        }
    }
}</pre></div><div xmlns="" class="console_widget" data-snippet=":CONSOLE:"></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="field-match"></a>Require Field Match<a xmlns="" href="https://github.com/elastic/elasticsearch/edit/5.1/docs/reference/search/request/highlighting.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h3></div></div></div><p><code class="literal">require_field_match</code> can be set to <code class="literal">false</code> which will cause any field to
be highlighted regardless of whether the query matched specifically on them.
The default behaviour is <code class="literal">true</code>, meaning that only fields that hold a query
match will be highlighted.</p><div xmlns="" class="pre_wrapper"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">GET /_search
{
    "query" : {
        "match": { "user": "kimchy" }
    },
    "highlight" : {
        "require_field_match": false,
        "fields": {
                "_all" : { "pre_tags" : ["&lt;em&gt;"], "post_tags" : ["&lt;/em&gt;"] }
        }
    }
}</pre></div><div xmlns="" class="console_widget" data-snippet=":CONSOLE:"></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="boundary-characters"></a>Boundary Characters<a xmlns="" href="https://github.com/elastic/elasticsearch/edit/5.1/docs/reference/search/request/highlighting.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h3></div></div></div><p>When highlighting a field using the fast vector highlighter,
<code class="literal">boundary_chars</code> can be configured to define what constitutes a boundary
for highlighting. It’s a single string with each boundary character
defined in it. It defaults to <code class="literal">.,!? \t\n</code>.</p><p>The <code class="literal">boundary_max_scan</code> allows to control how far to look for boundary
characters, and defaults to <code class="literal">20</code>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="matched-fields"></a>Matched Fields<a xmlns="" href="https://github.com/elastic/elasticsearch/edit/5.1/docs/reference/search/request/highlighting.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h3></div></div></div><p>The Fast Vector Highlighter can combine matches on multiple fields to
highlight a single field using <code class="literal">matched_fields</code>.  This is most
intuitive for multifields that analyze the same string in different
ways.  All <code class="literal">matched_fields</code> must have <code class="literal">term_vector</code> set to
<code class="literal">with_positions_offsets</code> but only the field to which the matches are
combined is loaded so only that field would benefit from having
<code class="literal">store</code> set to <code class="literal">yes</code>.</p><p>In the following examples <code class="literal">content</code> is analyzed by the <code class="literal">english</code>
analyzer and <code class="literal">content.plain</code> is analyzed by the <code class="literal">standard</code> analyzer.</p><div xmlns="" class="pre_wrapper"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">GET /_search
{
    "query": {
        "query_string": {
            "query": "content.plain:running scissors",
            "fields": ["content"]
        }
    },
    "highlight": {
        "order": "score",
        "fields": {
            "content": {
                "matched_fields": ["content", "content.plain"],
                "type" : "fvh"
            }
        }
    }
}</pre></div><div xmlns="" class="console_widget" data-snippet=":CONSOLE:"></div><p>The above matches both "run with scissors" and "running with scissors"
and would highlight "running" and "scissors" but not "run". If both
phrases appear in a large document then "running with scissors" is
sorted above "run with scissors" in the fragments list because there
are more matches in that fragment.</p><div xmlns="" class="pre_wrapper"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">GET /_search
{
    "query": {
        "query_string": {
            "query": "running scissors",
            "fields": ["content", "content.plain^10"]
        }
    },
    "highlight": {
        "order": "score",
        "fields": {
            "content": {
                "matched_fields": ["content", "content.plain"],
                "type" : "fvh"
            }
        }
    }
}</pre></div><div xmlns="" class="console_widget" data-snippet=":CONSOLE:"></div><p>The above highlights "run" as well as "running" and "scissors" but
still sorts "running with scissors" above "run with scissors" because
the plain match ("running") is boosted.</p><div xmlns="" class="pre_wrapper"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">GET /_search
{
    "query": {
        "query_string": {
            "query": "running scissors",
            "fields": ["content", "content.plain^10"]
        }
    },
    "highlight": {
        "order": "score",
        "fields": {
            "content": {
                "matched_fields": ["content.plain"],
                "type" : "fvh"
            }
        }
    }
}</pre></div><div xmlns="" class="console_widget" data-snippet=":CONSOLE:"></div><p>The above query wouldn’t highlight "run" or "scissor" but shows that
it is just fine not to list the field to which the matches are combined
(<code class="literal">content</code>) in the matched fields.</p><div xmlns="" class="note admon"><div class="icon"><img alt="Note" src="images/icons/note.png" /></div><div class="admon_content"><p xmlns="http://www.w3.org/1999/xhtml">Technically it is also fine to add fields to <code class="literal">matched_fields</code> that
don’t share the same underlying string as the field to which the matches
are combined.  The results might not make much sense and if one of the
matches is off the end of the text then the whole query will fail.</p></div></div><div xmlns="" class="note admon"><div class="icon"><img alt="Note" src="images/icons/note.png" /></div><div class="admon_content"><p xmlns="http://www.w3.org/1999/xhtml">There is a small amount of overhead involved with setting
<code class="literal">matched_fields</code> to a non-empty array so always prefer</p><div class="pre_wrapper"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">    "highlight": {
        "fields": {
            "content": {}
        }
    }</pre></div><p xmlns="http://www.w3.org/1999/xhtml">to</p><div class="pre_wrapper"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">    "highlight": {
        "fields": {
            "content": {
                "matched_fields": ["content"],
                "type" : "fvh"
            }
        }
    }</pre></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="phrase-limit"></a>Phrase Limit<a xmlns="" href="https://github.com/elastic/elasticsearch/edit/5.1/docs/reference/search/request/highlighting.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h3></div></div></div><p>The fast vector highlighter has a <code class="literal">phrase_limit</code> parameter that prevents
it from analyzing too many phrases and eating tons of memory.  It defaults
to 256 so only the first 256 matching phrases in the document scored
considered.  You can raise the limit with the <code class="literal">phrase_limit</code> parameter but
keep in mind that scoring more phrases consumes more time and memory.</p><p>If using <code class="literal">matched_fields</code> keep in mind that <code class="literal">phrase_limit</code> phrases per
matched field are considered.</p><h3><a id="explicit-field-order"></a>Field Highlight Order<a xmlns="" href="https://github.com/elastic/elasticsearch/edit/5.1/docs/reference/search/request/highlighting.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h3><p>Elasticsearch highlights the fields in the order that they are sent.  Per the
json spec objects are unordered but if you need to be explicit about the order
that fields are highlighted then you can use an array for <code class="literal">fields</code> like this:</p><div xmlns="" class="pre_wrapper"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">    "highlight": {
        "fields": [
            {"title":{ /*params*/ }},
            {"text":{ /*params*/ }}
        ]
    }</pre></div><p>None of the highlighters built into Elasticsearch care about the order that the
fields are highlighted but a plugin may.</p></div></div><div xmlns="" class="navfooter"><span class="prev"><a href="search-request-post-filter.html">
              « 
              Post filter</a>
           
        </span><span class="next">
           
          <a href="search-request-rescore.html">Rescoring
               »
            </a></span></div></body></html>